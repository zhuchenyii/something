# 文件系统中跳转
* 普通用户登录后, `/home`目录是**唯一**允许用户写入文件的位置

* 快速改变当前工作目录

  快捷键 | 运行结果
  :-: | :-
  `cd` | 将当前工作目录更改为当前用户的`/home`目录
  `cd -` | 将当前工作目录更改为先前的工作目录
  `cd ~user_name` | 将当前工作目录更改为此用户的`/home`目录

# 探究操作系统
* `ls`常用选项

  选项 | 长选项 | 描述
  :-: | :-: | :-
  -a | --all | 列出所有文件, 包括以`.`开头的隐藏文件
  -d | --directory | 通常和`-l`结合使用显示指定目录的详细信息
  -F | --classify | 显示文件的指示符, 其中<br>`*`表示可执行文件<br>`/`表示目录<br>`@`表示符号链接<br>`|`表示管道文件<br>`=`表示套接字<br>`>`表示进程间通信设备
  -i | --inode | 显示文件索引节点
  -h | --human-readable | 通常和`-l`结合使用以人们可读的格式显示文件的大小
  -l | | 以长格式显示结果
  -r | --reverse | 以相反的顺序显示结果
  -S | | 按照文件大小显示结果
  -t | | 按照修改时间显示结果

* `ls -l`长格式列表字段
  ```bash
  -rw-r--r-- 1 root root 3576296 2020-08-13 15:58 test.txt
  ```

  字段 | 含义
  :-: | :-
  -rw-r--r-- | 文件的访问权限
  1 | 文件的硬链接数量
  root | 文件所有者的用户名
  root | 文件所属用户组名
  3576296 | 以字节数表示的文件大小
  2020-08-13 15:58 | 上次文件修改的时间
  test.txt | 文件名

* 可以使用`file filename`显示文件格式

* `less`常用的键盘命令

  命令 | 行为
  :-: | :-
  Page Up or b | 向上翻滚一页
  Page Down or space | 向下翻滚一页
  Up Arrow | 向上翻滚一行
  Down Arrow | 向下翻滚一行
  G | 移动到最后一行
  1G or g | 移动到开头一行
  /characters | 向前查找指定的字符串
  n | 向前查找下一个出现的字符串, 这个字符串是之前所指定查找的
  h | 显示帮助屏幕
  q | 退出`less`程序

* 常见目录

  目录 | 描述
  :-: | :-
  `/` | 根目录
  `/bin` | 包含系统启动和运行所必须的二进制程序
  `/boot` | 包含Linux内核、初始RAM磁盘镜像(用于启动时所需的驱动)和启动记载程序
  `/dev` | 包含设备节点, 在这个目录里内核维护着所有设备的列表
  `/etc` | 包含所有系统层面的配置文件, 其中<br>`/etc/crontab`定义自动运行的任务<br>`/etc/fstab`包含存储设备的列表以及与其相关的挂载点<br>`/etc/passwd`包含用户账号列表
  `/home` | 一般系统会在此目录下为每个用户分配目录, 普通用户只能在自己的目录下写入文件
  `/lib` | 包含核心系统程序所使用的共享库文件
  `/lost+found` | 每个使用Linux文件系统的格式化分区或设备都会有这个目录, 当部分恢复一个损坏的文件系统时会用到这个目录<br>这个目录应该是空的, 除非文件系统真正的损坏了
  `/media` | 包含可移动介质的挂载点, 当可移动介质连接到计算机之后会自动挂载到这个目录节点下
  `/opt` | 存储可能安装在系统中的商业软件产品
  `/proc` | 由Linux内核维护的虚拟文件系统, 目录中的文件描述了内核是如何监管计算机的
  `/root` | root账户的`/home`目录
  `/sbin` | 包含系统二进制文件, 通常为超级用户保留
  `/tmp` | 存储由各种程序创建的临时文件
  `/usr` | 包含普通用户所需要的所有程序和文件
  `/usr/bin` | 包含系统安装的可执行程序
  `/usr/lib` | 包含由`/usr/bin`目录中的程序所用的共享库
  `/usr/local` | 非系统发行版自带程序的安装目录, 通常由源码编译的程序会安装在`/usr/local/bin`目录下
  `/usr/sbin` | 包含系统管理程序
  `/usr/share` | 包含许多由`/usr/bin`目录中的程序使用的共享数据
  `/usr/share/doc` | 包含安装在系统中软件的文档
  `/var` | 存放动态文件, 包含各种数据库、假脱机文件、用户邮件等
  `/var/log` | 包含日志文件、各种系统活动的记录

# 操作文件和目录
* 字符类

  字符类 | 意义
  :-: | :-
  [:alnum:] | 匹配任意一个字母或数字
  [:alpha:] | 匹配任意一个字母
  [:digit:] | 匹配任意一个数字
  [:lower:] | 匹配任意一个小写字母
  [:upper:] | 匹配任意一个大写字母

* 通配符

  通配符 | 意义
  :-: | :-
  * | 匹配任意多个字符(包括0个或1个)
  ? | 匹配任意一个字符(不包括0个)
  [characters] | 匹配任意一个属于字符集中的字符
  [!characters] | 匹配任意一个不是字符集中的字符
  [[:class:]] | 匹配任意一个属于指定字符类中的字符

* 尽量避免使用`[A-Z]`、`[a-z]`形式的字符范围表示法, 因为它们不会产生你期望的输出结果

* 在描述一个命令时, 当有三个圆点跟在一个命令的参数后面, 这意味着这个参数可以重复

* `cp`常用选项

  <div style="width: 30pt">选项</div> | <div style="width: 60pt">长选项</div> | 描述
  :-: | :-: | :-
  -a | --archive | 复制文件和目录, 以及它们的属性, 包括所有权和权限。通常, 副本具有用户所操作文件的默认属性
  -i | --interactive | 在重写已存在文件之前, 提示用户确认。如果这个选项不指定,`cp`命令会默认重写文件
  -r | --recursive | 递归地复制目录及目录中的内容。当复制目录时, 需要这个选项
  -u | --update | 当把文件从一个目录复制到另一个目录时, 仅复制目标目录中不存在的文件, 或者是文件内容新于目标目录中已经存在的文件
  -v | --verbose | 显示翔实的命令操作信息

* `mv`和`rm`常用选项和`cp`基本一致, 本文档中不再赘述。其中`rm`还有以下常用选项

  选项 | 长选项 | 描述
  :-: | :-: | :-
  -f | --force | 忽视不存在的文件, 不显示提示信息。此选项覆盖-i (--interactive)选项

  **`Linux`系统中没有复原命令, 小心`rm`!**

* `ln`常用选项
  选项 | 长选项 | 描述
  :-: | :-: | :-
  -f | --force | 强制执行
  -i | --interactive | 文件存在时提示用户是否覆盖
  -n | --no-dereference | 把符号链接视为一般目录
  -s | --symbolic | 符号链接
  -v | --verbose | 显示详细的处理过程

* 硬链接的局限性:\
  1、一个硬链接不能关联它所在文件系统之外的文件, 也就是说一个链接不能关联与链接本身不在同一个磁盘分区的文件\
  2、一个硬链接不能关联一个目录

* 由于文件名是由硬链接创建的, 每个文件**至少**有一个硬链接

* 当一个硬链接被删除时, 这个链接被删除, 但是文件本身的内容任然存在 (也就是说它所占的磁盘空间不会被重新分配), 直到所有关联这个文件的链接都删除掉

* 建议使用**相对路径**建立符号链接, 因为它允许一个包括符号链接的目录重命名或移动, 而不会破坏链接

* 符号链接执行的大多数文件操作是针对链接的对象, 而不是链接的本身。`rm`命令是个特例, 当你删除链接的时候, 删除链接本身而不是链接的对象

# 使用命令
* 命令的四种形式\
  1、可执行程序, 可以是由诸如C和C++语言写成的程序编译成的二进制文件, 也可以是由诸如shell、perl、python、ruby等脚本语言写成的程序\
  2、内建于shell自身的命令 (builtins)\
  3、shell函数\
  4、命令别名

* 使用`which`显示可执行程序的位置, 此命令只对可执行程序有效, 不包括内建命令和命令别名

* 使用`alias`创建命令\
  1、使用`type <commandName>`判断命令名是否被占用, 当出现以下输出时表示未被占用
  ```bash
  -bash: type: <commandName>: not found
  ```
  2、创建命令别名
  ```bash
  alias <commandName>='<command1>; <command2>; <command3>...'
  ```
  3、使用`unalias <commandName>`删除别名\
  **如果在命令行中定义别名的话, 在shell会话结束后, 别名便会消失**

# 重定向
* 标准输出重定向
  ```bash
  # 重写文件
  <command> > <fileName>
  # 追加文件
  <command> >> <fileName>
  ```